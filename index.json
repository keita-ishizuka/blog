[{"content":"概要 $m \\times n$行列$M$のグラム行列$MM^T$と，転置行列$M^T$のグラム行列$M^TM$との間に成り立つ，固有値についての定理を証明とともに解説する．\n定理 $M$を実数上の$m \\times n$行列とする． $MM^T$と$M^TM$の零でない固有値は重複度を含めて一致する．\n証明 $\\theta \\neq 0$を$M$の固有値とする． 行列$G$の$\\theta$固有空間を$W_G(\\theta)$で表す． 写像$u \\mapsto M^T u$は$W_{MM^T}(\\theta)$から$W_{M^TM}(G)$への単射である． それは，以下のようにして確かめられる：\n線型写像であることは自明． $M^TM(M^Tu)=M^T(MM^Tu)=M^T \\theta u =\\theta (M^T u)$より$M^Tu \\in W_{M^TM}(\\theta)$． $M^T u = M^T v \\Rightarrow MM^T(u-v)=0 \\Rightarrow u=v$より単射（$u-v \\in W_{MM^T}(\\theta)$に注意）． 同様にして，$u \\mapsto M u$は$W_{M^TM}(\\theta)$から$W_{MM^T}(\\theta)$への単射準同型写像である． よって，零でない固有値$\\theta$について，\n$\\theta$が$MM^T$の固有値 $\\Leftrightarrow$ $\\theta$が$M^TM$の固有値． $|W_{MM^T}(\\theta)|=|W_{M^TM}(\\theta)|$． が従う． これより，定理は示された． ■\n注意 上の証明で示したのは，幾何学的重複度の一致である． 一方で定理の主張は，代数的重複度の一致だ． 一般に，後者ならば前者が成立しますが，逆は成立しない． なので，証明は不十分に思われる．\nしかし，次の理由で証明は十分である： グラム行列は対称行列なので対角化可能． 対角化可能な行列の代数的重複度は幾何学的重複度に一致する．\n","permalink":"https://keita-ishizuka.github.io/blog/posts/gram_matrix/","summary":"概要 $m \\times n$行列$M$のグラム行列$MM^T$と，転置行列$M^T$のグラム行列$M^TM$との間に成り立つ，固有値についての定理を証明とともに解説する．\n定理 $M$を実数上の$m \\times n$行列とする． $MM^T$と$M^TM$の零でない固有値は重複度を含めて一致する．\n証明 $\\theta \\neq 0$を$M$の固有値とする． 行列$G$の$\\theta$固有空間を$W_G(\\theta)$で表す． 写像$u \\mapsto M^T u$は$W_{MM^T}(\\theta)$から$W_{M^TM}(G)$への単射である． それは，以下のようにして確かめられる：\n線型写像であることは自明． $M^TM(M^Tu)=M^T(MM^Tu)=M^T \\theta u =\\theta (M^T u)$より$M^Tu \\in W_{M^TM}(\\theta)$． $M^T u = M^T v \\Rightarrow MM^T(u-v)=0 \\Rightarrow u=v$より単射（$u-v \\in W_{MM^T}(\\theta)$に注意）． 同様にして，$u \\mapsto M u$は$W_{M^TM}(\\theta)$から$W_{MM^T}(\\theta)$への単射準同型写像である． よって，零でない固有値$\\theta$について，\n$\\theta$が$MM^T$の固有値 $\\Leftrightarrow$ $\\theta$が$M^TM$の固有値． $|W_{MM^T}(\\theta)|=|W_{M^TM}(\\theta)|$． が従う． これより，定理は示された． ■\n注意 上の証明で示したのは，幾何学的重複度の一致である． 一方で定理の主張は，代数的重複度の一致だ． 一般に，後者ならば前者が成立しますが，逆は成立しない． なので，証明は不十分に思われる．\nしかし，次の理由で証明は十分である： グラム行列は対称行列なので対角化可能． 対角化可能な行列の代数的重複度は幾何学的重複度に一致する．","title":"グラム行列の固有値についての定理"},{"content":"概要 以下の問題を，bitDP で解き python で実装する． bitDP は，冪集合の特性関数と DP（動的計画法）を組み合わせたアルゴリズムである．\n巡回セールスマン問題 - atcoder\n前提知識 bit の考え方 ある集合の全ての部分集合の集合を，冪集合という． 例えば，$S=\\{1,2,3\\}$について，$2^S= \\{ \\phi,\\{ 1 \\},\\{ 2 \\},\\{ 3 \\},\\{ 1,2 \\},\\{ 1,3\\},\\{ 2,3 \\},S \\}$だ． 集合$S$の冪集合の濃度は，$2^{|S|}$である． これにちなんで，集合$S$の冪集合は$2^{S}$と表されることが多い． $S$の要素$i$を含む場合は$x_i=1$，そうでない場合は$x_i=0$となるようなベクトル$x$を定義する． このベクトルの集合と$2^S$には全単射が存在する． 例えば，$\\{1,2\\} \\in S$は$(1,1,0)$に対応する．\nこの性質を使って，濃度$n$の集合の冪集合を$0,1,\\dots,2^n-1$の 2 進数表現で表す手法が，俗にいう bit である． 計算機科学界隈では，2 進数を bit と呼ぶことが多いので，そのような名前がついたのだろう．\n上記の考え方を使う手法に， bit 全探索がある． これは bitDP より理解しやすい． 未学習の読者は bitDP の前に bit 全探索を学習することを推奨する．\n動的計画法の考え方 動的計画法の定義は曖昧である． 複数の異なる手法を総称して，動的計画法と呼んでいる． 漸化式を効率よく求める方法も，巡回セールスマン問題の解法も，一括りに動的計画法である． 動的計画法は英語で，Dynamic Programming と言う． 頭文字をとって，DP と呼ばれている． 以下，DP と呼ぶ．\nDP と呼ばれるアルゴリズムに共通する性質をあえて述べれば，\n部分問題を繰り返し解くことで問題そのものの解答になる 部分問題においては，その時点での或る値のみが重要であり，その値を得るための手続きは保存されていなくても構わない と言う場合に，用いられることだ．\n例えば，（一般項を知らないふりをして）フィボナッチ数列の第$n$項を計算するのが簡単な DP の例である． フィボナッチ数列の漸化式は$f(n+2)=f(n+1)+f(n)$である． これを，$n$が小さい方から順に計算して求めてゆくのが計算の概要である． これに際して，\n漸化式を順次計算することで，第$n$項が得られる $f(n+2)=f(n+1)+f(n)$を計算する際には$f(n+1), f(n)$の値のみが重要であり，$f(n-1),\\dots,f(1)$の値は不要． と上記の性質を満たしている．\n解法 まずは全探索による解答を与える： $n!$通りの経路のそれぞれについて，コストを計算する． そして，最小なコストを有する経路を出力する．\nしかし，$O(n!)$では本問題の制約下で制限時間内に計算が終わらない． より効率的な方法を考える必要がある．\n問題の条件下で，最小コストを与える経路が求められたとしよう． つまり，いわゆる巡回セールスマンが最小コストを与える経路を通って点$0$に戻ってきたことを想像する． 点$0$に戻ってくる直前に，彼はどの点にいたのだろうか． 点$1,2,\\dots,(N-1)$が候補である． このうち，\n（点$i$までの最小コスト）+（点$i$から点$0$へ移動するコスト）が最小となる点$i$\nを，セールスマンは通ったのである． この式の中に，巡回セールスマンが点$i$までどのような経路を辿ったかは現れていない．\nつまり，最小コストの計算においては\nどの点を訪問ずみか 現在どの点にいるか 現時点での最小コスト のみを保持していればよく，経路は不要である．\nよって，\nDP[i][j] =（2 進数iで表される部分集合を訪問ずみで，現在は点jにいる場合の，最小コスト）\nを更新していき，DP[-1][0]（全て訪問済みかつ点$0$にいる状態の最小コスト）を求めれば良い．\n実装 python で実装した．\nn = int(input()) A = [[*map(int, input().split())] for _ in range(n)] DP = [[10**18 for _ in range(n)] for _ in range(1 \u0026lt;\u0026lt; n)] DP[0][0] = 0 for i in range(1 \u0026lt;\u0026lt; n): for j in range(n): # 現在いる点 for k in range(n): # 次に訪問する点 if i \u0026amp; (1 \u0026lt;\u0026lt; k): continue DP[i + (1 \u0026lt;\u0026lt; k)][k] = min(DP[i + (1 \u0026lt;\u0026lt; k)][k], DP[i][j] + A[j][k]) print(DP[-1][0]) 計算量は，$O(2^nn^2)$である．\n注意 以下の文がない場合は，行列$A$ で表されるグラフにおいて，点$0$を何度も経由する経路のコストが出力されてしまう． これは，各点をちょうど一回のみ通ると言う制約を満たさず，不適．\nif i \u0026amp; (1 \u0026lt;\u0026lt; k): continue $$ A= \\begin{pmatrix} 0\u0026amp;1\u0026amp;1\u0026amp;1\\\\ 1\u0026amp;0\u0026amp;9\u0026amp;9\\\\ 1\u0026amp;9\u0026amp;0\u0026amp;9\\\\ 1\u0026amp;9\u0026amp;9\u0026amp;0\\\\ \\end{pmatrix} $$\n注意 初期状態で点$0$にいるのだから，DP[1][0]=0と初期化したくなる． しかし，一度通った点は通れないようにプログラムされているため，点$0$に戻って来られなくなる． 初期状態はグラフ外の点にいて，最後に点$0$を訪れるような巡回を考えていると思えば，DP[0][0]=0は自然である．\n","permalink":"https://keita-ishizuka.github.io/blog/posts/traveling_salesman/","summary":"概要 以下の問題を，bitDP で解き python で実装する． bitDP は，冪集合の特性関数と DP（動的計画法）を組み合わせたアルゴリズムである．\n巡回セールスマン問題 - atcoder\n前提知識 bit の考え方 ある集合の全ての部分集合の集合を，冪集合という． 例えば，$S=\\{1,2,3\\}$について，$2^S= \\{ \\phi,\\{ 1 \\},\\{ 2 \\},\\{ 3 \\},\\{ 1,2 \\},\\{ 1,3\\},\\{ 2,3 \\},S \\}$だ． 集合$S$の冪集合の濃度は，$2^{|S|}$である． これにちなんで，集合$S$の冪集合は$2^{S}$と表されることが多い． $S$の要素$i$を含む場合は$x_i=1$，そうでない場合は$x_i=0$となるようなベクトル$x$を定義する． このベクトルの集合と$2^S$には全単射が存在する． 例えば，$\\{1,2\\} \\in S$は$(1,1,0)$に対応する．\nこの性質を使って，濃度$n$の集合の冪集合を$0,1,\\dots,2^n-1$の 2 進数表現で表す手法が，俗にいう bit である． 計算機科学界隈では，2 進数を bit と呼ぶことが多いので，そのような名前がついたのだろう．\n上記の考え方を使う手法に， bit 全探索がある． これは bitDP より理解しやすい． 未学習の読者は bitDP の前に bit 全探索を学習することを推奨する．\n動的計画法の考え方 動的計画法の定義は曖昧である． 複数の異なる手法を総称して，動的計画法と呼んでいる． 漸化式を効率よく求める方法も，巡回セールスマン問題の解法も，一括りに動的計画法である． 動的計画法は英語で，Dynamic Programming と言う． 頭文字をとって，DP と呼ばれている． 以下，DP と呼ぶ．\nDP と呼ばれるアルゴリズムに共通する性質をあえて述べれば，","title":"巡回セールスマン問題をbitDPで解きpythonで実装"},{"content":"以下の記事で，マイクロソフトの入社試験問題とされている「金の延べ棒」が面白かった． これが解けたら Google 採用！？一流企業の入社試験がユニークで面白い！！\n問題は以下の通り．\nあなたの会社の社員の一人が、給料を金の地金で日払いで払うように求めています。あなたは、この社員の７日分の給料に相当する値段の金の延べ棒を持っています。棒は既に７等分に切れ目が入っています。延べ棒を２箇所だけ切断してよく、１日が終わるごとにこの社員と精算しなければならないとしてどうすればいいでしょう？\n2 進数表記で $n$ 桁有れば$2^n$種類の数を表せるという性質を使った問題である． この問題自体は非常に簡単であるので，次のように一般化した．\n問題 無限の長さの金の延べ棒に，等間隔に切れ目が入っている． 隣り合う切れ目の間にある金の価値は，上記の社員の一日分の給料に相当する． 切れ目にそって切断して$k$個の金塊を作る場合，最大何日間連続して社員の給与を精算できるかを$k$で表せ．■\n例えば，$k=3$の場合は，上記の問題そのものである． 金の延べ棒を$3$つに切断する際に，各々の長さが$1,2,4$となるように切断すれば$7$日分連続で給与精算ができる．\nそのように考えると，一般には$1,2,4,8,\u0026hellip;$の長さを持つような切れ目で切断して，$(2^k-1)$日と回答したくなる． しかし，$3$進数表記の方がより長い日数の給与を精算できることはあり得ないだろうか． 具体的には，$1,1,3,3,9,9,..$と切断した方が良いのではないだろうか． 同様に，$4$進数，$5$進数，\u0026hellip;はどうだろうか． あらゆる場合と比較して，常に$2$進数に基づいた$1,2,4,8,\u0026hellip;$の切断が最大の日数の精算を可能にする証明はどのようにするのだろう．\n解答 3 進数に基づいて，$1,1,3,3,9,9,\u0026hellip;$と$k$個に切断した場合に連続して支払える日数$f_3(k)$は\n$$ f_3(k)= \\begin{cases} 3^{k/2}-1 \u0026amp; \\textrm{if} \u0026amp; k \\equiv 0 \\pmod 2,\\\\ 2 \\cdot 3^{(k-3)/2}-1 \u0026amp; \\textrm{if} \u0026amp; k \\equiv 1 \\pmod 2. \\\\ \\end{cases} $$\n正の整数$k$について，$3^{k/2} -1 \u0026gt; 2 \\cdot 3^{(k-3)/2}-1$である． 同様にして，$n$進数に基づく$k$個の切断方法では，連続して支払える日数は$n^{k/(n-1)} - 1 $を超えないことがわかる．\nよって，$2^k \\ge n^{k/(n-1)}$を示せば，あらゆる$n \\ge 2$進数に基づく切り方のうちで，2 進数に基づくものが最良だと証明できる． これは，関数$f(x)=\\frac{log(x)}{x-1}$が$x\\ge2$で単調減少であることから導ける． よって，$(2^k-1)$が最大の日数である．■\n数学の本で，証明に適度に飛躍があって，その間を自分で埋めると推論の能力が向上する作りになっているものが筆者は好きである． それに倣って，上の証明も事細かに説明しないようにした． 興味を覚えた読者は，練習問題として，行間を埋めてみてほしい．\n高校数学の多くの分野を総合的に使うので，受験生のための練習問題としてかなりいい問題なのではと思っている． また，上記の性質は計算機で 2 進数が使われていることの説明にもなっている，とこじつけて気持ち良くなるのにも使える．\n追記 上記で示したのはあらゆる$n \\ge 2$進数記法に基づいた切断方法のうちでは$2$進数に基づく切り方が最大の日数を与えることだ． $n$進数記法に基づかない切り方と比べても，上記の切り方が最良であることはどう証明すれば良いのだろうか．\n","permalink":"https://keita-ishizuka.github.io/blog/posts/interview_gold_problem/","summary":"以下の記事で，マイクロソフトの入社試験問題とされている「金の延べ棒」が面白かった． これが解けたら Google 採用！？一流企業の入社試験がユニークで面白い！！\n問題は以下の通り．\nあなたの会社の社員の一人が、給料を金の地金で日払いで払うように求めています。あなたは、この社員の７日分の給料に相当する値段の金の延べ棒を持っています。棒は既に７等分に切れ目が入っています。延べ棒を２箇所だけ切断してよく、１日が終わるごとにこの社員と精算しなければならないとしてどうすればいいでしょう？\n2 進数表記で $n$ 桁有れば$2^n$種類の数を表せるという性質を使った問題である． この問題自体は非常に簡単であるので，次のように一般化した．\n問題 無限の長さの金の延べ棒に，等間隔に切れ目が入っている． 隣り合う切れ目の間にある金の価値は，上記の社員の一日分の給料に相当する． 切れ目にそって切断して$k$個の金塊を作る場合，最大何日間連続して社員の給与を精算できるかを$k$で表せ．■\n例えば，$k=3$の場合は，上記の問題そのものである． 金の延べ棒を$3$つに切断する際に，各々の長さが$1,2,4$となるように切断すれば$7$日分連続で給与精算ができる．\nそのように考えると，一般には$1,2,4,8,\u0026hellip;$の長さを持つような切れ目で切断して，$(2^k-1)$日と回答したくなる． しかし，$3$進数表記の方がより長い日数の給与を精算できることはあり得ないだろうか． 具体的には，$1,1,3,3,9,9,..$と切断した方が良いのではないだろうか． 同様に，$4$進数，$5$進数，\u0026hellip;はどうだろうか． あらゆる場合と比較して，常に$2$進数に基づいた$1,2,4,8,\u0026hellip;$の切断が最大の日数の精算を可能にする証明はどのようにするのだろう．\n解答 3 進数に基づいて，$1,1,3,3,9,9,\u0026hellip;$と$k$個に切断した場合に連続して支払える日数$f_3(k)$は\n$$ f_3(k)= \\begin{cases} 3^{k/2}-1 \u0026amp; \\textrm{if} \u0026amp; k \\equiv 0 \\pmod 2,\\\\ 2 \\cdot 3^{(k-3)/2}-1 \u0026amp; \\textrm{if} \u0026amp; k \\equiv 1 \\pmod 2. \\\\ \\end{cases} $$\n正の整数$k$について，$3^{k/2} -1 \u0026gt; 2 \\cdot 3^{(k-3)/2}-1$である． 同様にして，$n$進数に基づく$k$個の切断方法では，連続して支払える日数は$n^{k/(n-1)} - 1 $を超えないことがわかる．\nよって，$2^k \\ge n^{k/(n-1)}$を示せば，あらゆる$n \\ge 2$進数に基づく切り方のうちで，2 進数に基づくものが最良だと証明できる． これは，関数$f(x)=\\frac{log(x)}{x-1}$が$x\\ge2$で単調減少であることから導ける． よって，$(2^k-1)$が最大の日数である．■\n数学の本で，証明に適度に飛躍があって，その間を自分で埋めると推論の能力が向上する作りになっているものが筆者は好きである． それに倣って，上の証明も事細かに説明しないようにした． 興味を覚えた読者は，練習問題として，行間を埋めてみてほしい．","title":"金の延べ棒の問題の一般化"},{"content":"経歴 東北大学工学部卒業 東北大学大学院情報科学研究科修士号取得 東北大学大学院情報科学研究科博士課程在学中 能力がわかる数値やリンク等 英語：TOEIC 950 点 競技プログラミング：atcoder プログラミング：GitHub 研究：ORCID を参照． 作った物，書いた物 Combinatorics For Programmers 競プロと代数学 ","permalink":"https://keita-ishizuka.github.io/blog/profile/","summary":"経歴 東北大学工学部卒業 東北大学大学院情報科学研究科修士号取得 東北大学大学院情報科学研究科博士課程在学中 能力がわかる数値やリンク等 英語：TOEIC 950 点 競技プログラミング：atcoder プログラミング：GitHub 研究：ORCID を参照． 作った物，書いた物 Combinatorics For Programmers 競プロと代数学 ","title":"著者プロフィール"}]