---
title: "巡回セールスマン問題をbitDPで解きpythonで実装"
date: 2022-10-26T09:11:37+09:00
math: true
---

## 概要

以下の問題を，bitDP で解き python で実装する．
bitDP は，冪集合の特性関数と DP（動的計画法）を組み合わせたアルゴリズムである．

[巡回セールスマン問題 - atcoder](https://atcoder.jp/contests/typical-algorithm/tasks/typical_algorithm_c)

## 前提知識

### bit の考え方

ある集合の全ての部分集合の集合を，冪集合という．
例えば，$S=\\{1,2,3\\}$について，$2^S= \\{ \\phi,\\{ 1 \\},\\{ 2 \\},\\{ 3 \\},\\{ 1,2 \\},\\{ 1,3\\},\\{ 2,3 \\},S \\}$だ．
集合$S$の冪集合の濃度は，$2^{|S|}$である．
これにちなんで，集合$S$の冪集合は$2^{S}$と表されることが多い．
$S$の要素$i$を含む場合は$x_i=1$，そうでない場合は$x_i=0$となるようなベクトル$x$を定義する．
このベクトルの集合と$2^S$には全単射が存在する．
例えば，$\\{1,2\\} \in S$は$(1,1,0)$に対応する．

この性質を使って，濃度$n$の集合の冪集合を$0,1,\dots,2^n-1$の 2 進数表現で表す手法が，俗にいう bit である．
計算機科学界隈では，2 進数を bit と呼ぶことが多いので，そのような名前がついたのだろう．

上記の考え方を使う手法に， bit 全探索がある．
これは bitDP より理解しやすい．
未学習の読者は bitDP の前に bit 全探索を学習することを推奨する．

### 動的計画法の考え方

動的計画法の定義は曖昧である．
複数の異なる手法を総称して，動的計画法と呼んでいる．
漸化式を効率よく求める方法も，巡回セールスマン問題の解法も，一括りに動的計画法である．
動的計画法は英語で，Dynamic Programming と言う．
頭文字をとって，DP と呼ばれている．
以下，DP と呼ぶ．

DP と呼ばれるアルゴリズムに共通する性質をあえて述べれば，

- 部分問題を繰り返し解くことで問題そのものの解答になる
- 部分問題においては，その時点での或る値のみが重要であり，その値を得るための手続きは保存されていなくても構わない

と言う場合に，用いられることだ．

例えば，（一般項を知らないふりをして）フィボナッチ数列の第$n$項を計算するのが簡単な DP の例である．
フィボナッチ数列の漸化式は$f(n+2)=f(n+1)+f(n)$である．
これを，$n$が小さい方から順に計算して求めてゆくのが計算の概要である．
これに際して，

- 漸化式を順次計算することで，第$n$項が得られる
- $f(n+2)=f(n+1)+f(n)$を計算する際には$f(n+1), f(n)$の値のみが重要であり，$f(n-1),\dots,f(1)$の値は不要．

と上記の性質を満たしている．

## 解法

まずは全探索による解答を与える：
$n!$通りの経路のそれぞれについて，コストを計算する．
そして，最小なコストを有する経路を出力する．

しかし，$O(n!)$では本問題の制約下で制限時間内に計算が終わらない．
より効率的な方法を考える必要がある．

問題の条件下で，最小コストを与える経路が求められたとしよう．
つまり，いわゆる巡回セールスマンが最小コストを与える経路を通って点$0$に戻ってきたことを想像する．
点$0$に戻ってくる直前に，彼はどの点にいたのだろうか．
点$1,2,\dots,(N-1)$が候補である．
このうち，

（点$i$までの最小コスト）+（点$i$から点$0$へ移動するコスト）が最小となる点$i$

を，セールスマンは通ったのである．
この式の中に，巡回セールスマンが点$i$までどのような経路を辿ったかは現れていない．

つまり，最小コストの計算においては

- どの点を訪問ずみか
- 現在どの点にいるか
- 現時点での最小コスト

のみを保持していればよく，経路は不要である．

よって，

`DP[i][j] =（2 進数iで表される部分集合を訪問ずみで，現在は点jにいる場合の，最小コスト）`

を更新していき，`DP[-1][0]`（全て訪問済みかつ点$0$にいる状態の最小コスト）を求めれば良い．

## 実装

python で実装した．

```python
n = int(input())
A = [[*map(int, input().split())] for _ in range(n)]

DP = [[10**18 for _ in range(n)] for _ in range(1 << n)]
DP[0][0] = 0

for i in range(1 << n):
    for j in range(n): # 現在いる点
        for k in range(n): # 次に訪問する点
            if i & (1 << k):
                continue
            DP[i + (1 << k)][k] = min(DP[i + (1 << k)][k], DP[i][j] + A[j][k])
print(DP[-1][0])
```

計算量は，$O(2^nn^2)$である．

### 注意

以下の文がない場合は，行列$A$ で表されるグラフにおいて，点$0$を何度も経由する経路のコストが出力されてしまう．
これは，各点をちょうど一回のみ通ると言う制約を満たさず，不適．

```python
if i & (1 << k):
    continue
```

$$
A=
\begin{pmatrix}
0&1&1&1\\\
1&0&9&9\\\
1&9&0&9\\\
1&9&9&0\\\
\end{pmatrix}
$$

### 注意

初期状態で点$0$にいるのだから，`DP[1][0]=0`と初期化したくなる．
しかし，一度通った点は通れないようにプログラムされているため，点$0$に戻って来られなくなる．
初期状態はグラフ外の点にいて，最後に点$0$を訪れるような巡回を考えていると思えば，`DP[0][0]=0`は自然である．
